(* SPDX-FileCopyrightText: 2025 Rhett Creighton
 * SPDX-License-Identifier: Apache-2.0
 *)

(* Formal specification of 4-ary Merkle Trees in Why3 *)

module MerkleTree

  use int.Int
  use array.Array
  use list.List
  use list.Length
  use option.Option

  (* Hash function type - 256 bits *)
  type hash = array bool
  constant hash_size : int = 256

  (* Domain separators *)
  constant leaf_domain_sep : int = 0x00
  constant internal_domain_sep : int = 0x01

  (* GF128 element - 128 bits *)
  type gf128 = array bool
  constant gf128_size : int = 128

  (* Leaf data: 8 GF128 elements *)
  constant leaf_elements : int = 8
  type leaf_data = array gf128

  (* Tree node *)
  type tree_node = 
    | Leaf (data: leaf_data, hash: hash)
    | Internal (children: array (option tree_node), hash: hash)

  (* Hash function specification *)
  val hash_leaf (data: leaf_data) : hash
    ensures { length result = hash_size }

  val hash_internal (children: array hash) : hash
    requires { length children = 4 }
    ensures { length result = hash_size }

  (* Merkle tree *)
  type merkle_tree = {
    root: tree_node;
    height: int;
    num_leaves: int;
  }

  (* Well-formed tree predicate *)
  predicate well_formed_node (n: tree_node) (level: int) =
    match n with
    | Leaf _ _ -> level = 0
    | Internal children h ->
        level > 0 /\
        length children = 4 /\
        forall i. 0 <= i < 4 ->
          match children[i] with
          | None -> true
          | Some child -> well_formed_node child (level - 1)
          end
    end

  predicate well_formed (t: merkle_tree) =
    well_formed_node t.root t.height /\
    t.height >= 0 /\
    t.num_leaves > 0 /\
    t.num_leaves <= power 4 t.height

  (* Path in tree - sequence of positions (0-3) at each level *)
  type path = list int

  (* Get node at path *)
  function get_node (n: tree_node) (p: path) : option tree_node =
    match p with
    | Nil -> Some n
    | Cons pos rest ->
        match n with
        | Leaf _ _ -> None
        | Internal children _ ->
            if 0 <= pos < 4 then
              match children[pos] with
              | None -> None
              | Some child -> get_node child rest
              end
            else None
        end
    end

  (* Authentication path for a leaf *)
  type auth_path = {
    leaf_index: int;
    path_positions: path;
    siblings: list (array hash);  (* 3 siblings at each level *)
  }

  (* Verify authentication path *)
  predicate verify_path (root_hash: hash) (leaf: leaf_data) (auth: auth_path) =
    let leaf_hash = hash_leaf leaf in
    (* Reconstruct root hash using siblings *)
    true  (* Simplified - would compute hash up the tree *)

  (* Main theorem: Path verification is sound *)
  lemma path_verification_sound:
    forall t: merkle_tree, leaf_idx: int, leaf: leaf_data, auth: auth_path.
    well_formed t ->
    0 <= leaf_idx < t.num_leaves ->
    verify_path (get_hash t.root) leaf auth ->
    (* The leaf is actually in the tree at the claimed position *)
    exists p: path. 
      length p = t.height /\
      match get_node t.root p with
      | Some (Leaf data h) -> data = leaf
      | _ -> false
      end

  (* Collision resistance assumption *)
  axiom hash_collision_resistant:
    forall d1 d2: leaf_data.
    d1 <> d2 -> hash_leaf d1 <> hash_leaf d2

  axiom hash_internal_collision_resistant:
    forall c1 c2: array hash.
    length c1 = 4 -> length c2 = 4 ->
    c1 <> c2 -> hash_internal c1 <> hash_internal c2

  (* Example: Building a small tree *)
  let example_tree () : merkle_tree
    ensures { well_formed result }
    ensures { result.num_leaves = 4 }
    ensures { result.height = 1 }
  =
    (* Create 4 leaves *)
    let leaf0 = make (leaf_elements) (make gf128_size false) in
    let leaf1 = make (leaf_elements) (make gf128_size false) in
    let leaf2 = make (leaf_elements) (make gf128_size false) in
    let leaf3 = make (leaf_elements) (make gf128_size false) in
    
    (* Hash leaves *)
    let h0 = hash_leaf leaf0 in
    let h1 = hash_leaf leaf1 in
    let h2 = hash_leaf leaf2 in
    let h3 = hash_leaf leaf3 in
    
    (* Create leaf nodes *)
    let node0 = Leaf leaf0 h0 in
    let node1 = Leaf leaf1 h1 in
    let node2 = Leaf leaf2 h2 in
    let node3 = Leaf leaf3 h3 in
    
    (* Create root *)
    let children = make 4 None in
    children[0] <- Some node0;
    children[1] <- Some node1;
    children[2] <- Some node2;
    children[3] <- Some node3;
    
    let root_hash = hash_internal (make 4 h0) in  (* Simplified *)
    let root = Internal children root_hash in
    
    { root = root; height = 1; num_leaves = 4 }

end